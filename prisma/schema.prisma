generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum VerifiedStatus {
  none
  identity
  manual
}

enum PostVisibility {
  public
  verifiedOnly
  premiumOnly
  onlyMe
}

enum FollowVisibility {
  all
  verified
  premium
  none
}

enum PostMediaKind {
  image
  gif
}

enum PostMediaSource {
  upload
  giphy
}

// Start minimal. Add real domain models as you solidify your product.
model Example {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  name      String
}

model User {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  phone     String    @unique
  email     String?   @unique
  // Username stored as entered (case preserved). Uniqueness is enforced case-insensitively
  // via a functional unique index on LOWER(username) in a migration.
  username String?
  // Public profile fields.
  name String?
  bio  String?
  // Required onboarding fields (gates app access).
  // Stored as DateTime (UTC midnight) to keep Prisma portable.
  birthdate DateTime?
  interests String[] @default([])
  // Required onboarding acknowledgement (app store friendly wording; enforced in app).
  menOnlyConfirmed Boolean @default(false)
  // True when the user has explicitly chosen a username.
  usernameIsSet Boolean @default(false)
  // Minimal admin flag (will be replaced by real roles later).
  siteAdmin Boolean @default(false)
  // Premium flag (paid product access; used for visibility gating).
  premium Boolean @default(false)
  // Verified badge (more roles/permissions later).
  verifiedStatus VerifiedStatus @default(none)
  verifiedAt DateTime?
  unverifiedAt DateTime?
  // Follow list privacy (controls counts + follower/following lists).
  followVisibility FollowVisibility @default(all)
  // Public media (stored in object storage; API stores keys only).
  avatarKey String?
  avatarUpdatedAt DateTime?
  bannerKey String?
  bannerUpdatedAt DateTime?
  sessions  Session[]
  posts     Post[]
  boosts    Boost[]
  bookmarks Bookmark[]
  bookmarkCollections BookmarkCollection[]
  // Social graph (self-referential via Follow).
  // `following`: users this user follows (outgoing edges)
  // `followers`: users who follow this user (incoming edges)
  following Follow[] @relation("Follow_follower")
  followers Follow[] @relation("Follow_following")

  @@index([phone])
}

model Follow {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  followerId  String
  followingId String

  follower  User @relation("Follow_follower", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("Follow_following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId, createdAt])
  @@index([followingId, createdAt])
}

model Post {
  id         String         @id @default(cuid())
  createdAt  DateTime       @default(now())
  deletedAt  DateTime?
  body       String
  visibility PostVisibility @default(public)
  boostCount Int            @default(0)
  bookmarkCount Int         @default(0)
  boostScore Float?
  boostScoreUpdatedAt DateTime?

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  boosts Boost[]
  media  PostMedia[]
  bookmarks Bookmark[]

  @@index([userId, createdAt])
  @@index([createdAt])
}

model BookmarkCollection {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name String

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  bookmarks Bookmark[]

  @@unique([userId, name])
  @@index([userId, createdAt])
}

model Bookmark {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  postId String
  post   Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  collectionId String?
  collection   BookmarkCollection? @relation(fields: [collectionId], references: [id], onDelete: SetNull)

  @@unique([userId, postId])
  @@index([userId, createdAt])
  @@index([collectionId, createdAt])
  @@index([postId, createdAt])
}

model PostMedia {
  id        String         @id @default(cuid())
  createdAt DateTime       @default(now())
  kind      PostMediaKind
  source    PostMediaSource
  // For "upload" sources, `r2Key` is set; `url` is computed server-side from R2 base URL.
  r2Key     String?
  // For "giphy" sources, `url` is set (and optional mp4Url for better performance later).
  url       String?
  mp4Url    String?
  width     Int?
  height    Int?
  position  Int            @default(0)

  postId String
  post   Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId, position])
  @@index([postId, createdAt])
}

model Boost {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  postId String
  userId String

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId, createdAt])
  @@index([userId, createdAt])
}

// Singleton-ish table: holds site-wide configurable settings.
// Use `id=1` row as the canonical config.
model SiteConfig {
  id        Int      @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  postsPerWindow     Int @default(5)
  windowSeconds      Int @default(300)
}

model PhoneOtp {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  phone         String
  codeHash      String
  expiresAt     DateTime
  consumedAt    DateTime?
  resendAfterAt DateTime?

  @@index([phone, createdAt])
  @@index([expiresAt])
}

model Session {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  expiresAt DateTime
  revokedAt DateTime?
  tokenHash String    @unique

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}


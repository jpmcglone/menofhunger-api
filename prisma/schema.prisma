generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum VerifiedStatus {
  none
  identity
  manual
}

enum PostVisibility {
  public
  verifiedOnly
  premiumOnly
  onlyMe
}

enum FollowVisibility {
  all
  verified
  premium
  none
}

enum PostMediaKind {
  image
  gif
  video
}

enum PostMediaSource {
  upload
  giphy
}

enum NotificationKind {
  comment
  boost
  follow
  mention
  generic
}

// Start minimal. Add real domain models as you solidify your product.
model Example {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  name      String
}

model User {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  phone     String    @unique
  email     String?   @unique
  // Username stored as entered (case preserved). Uniqueness is enforced case-insensitively
  // via a functional unique index on LOWER(username) in a migration.
  username String?
  // Public profile fields.
  name String?
  bio  String?
  // Required onboarding fields (gates app access).
  // Stored as DateTime (UTC midnight) to keep Prisma portable.
  birthdate DateTime?
  interests String[] @default([])
  // Required onboarding acknowledgement (app store friendly wording; enforced in app).
  menOnlyConfirmed Boolean @default(false)
  // True when the user has explicitly chosen a username.
  usernameIsSet Boolean @default(false)
  // Minimal admin flag (will be replaced by real roles later).
  siteAdmin Boolean @default(false)
  // Premium flag (paid product access; used for visibility gating).
  premium Boolean @default(false)
  // Verified badge (more roles/permissions later).
  verifiedStatus VerifiedStatus @default(none)
  verifiedAt DateTime?
  unverifiedAt DateTime?
  // Follow list privacy (controls counts + follower/following lists).
  followVisibility FollowVisibility @default(all)
  // Public media (stored in object storage; API stores keys only).
  avatarKey String?
  avatarUpdatedAt DateTime?
  bannerKey String?
  bannerUpdatedAt DateTime?
  sessions  Session[]
  posts     Post[]
  boosts    Boost[]
  bookmarks Bookmark[]
  bookmarkCollections BookmarkCollection[]
  // Pinned post on profile (one per user; must be own post).
  pinnedPostId String? @unique
  pinnedPost   Post?   @relation("PinnedPost", fields: [pinnedPostId], references: [id], onDelete: SetNull)

  // Social graph (self-referential via Follow).
  // `following`: users this user follows (outgoing edges)
  // `followers`: users who follow this user (incoming edges)
  following Follow[] @relation("Follow_follower")
  followers Follow[] @relation("Follow_following")

  // Admin audit relations
  deletedPostMedia PostMedia[] @relation("PostMedia_deletedByAdmin")
  deletedMediaAssets MediaAsset[] @relation("MediaAsset_deletedByAdmin")
  mentionedIn PostMention[] @relation("PostMention_user")
  notificationsReceived Notification[] @relation("Notification_recipient")
  notificationsAsActor Notification[] @relation("Notification_actor")
  notificationsAsSubjectUser Notification[] @relation("Notification_subjectUser")
  pushSubscriptions PushSubscription[]
  userSearches     UserSearch[]

  @@index([phone])
}

model UserSearch {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  query     String   @db.VarChar(200)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([createdAt])
  @@index([query])
}

model PushSubscription {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  userId   String
  endpoint String   @db.Text
  p256dh   String   @db.Text
  auth     String   @db.Text
  userAgent String? @db.Text

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, endpoint])
  @@index([userId])
}

model Follow {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  followerId  String
  followingId String

  follower  User @relation("Follow_follower", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("Follow_following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId, createdAt])
  @@index([followingId, createdAt])
}

model Post {
  id         String         @id @default(cuid())
  createdAt  DateTime       @default(now())
  deletedAt  DateTime?
  body       String
  visibility PostVisibility @default(public)
  boostCount Int            @default(0)
  bookmarkCount Int         @default(0)
  commentCount Int          @default(0)
  boostScore Float?
  boostScoreUpdatedAt DateTime?

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  parentId String?
  parent   Post?   @relation("Post_replies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Post[] @relation("Post_replies")

  // Root post ID for thread hierarchy (null for root posts, set to root post ID for all replies in a thread)
  rootId String?
  root   Post?   @relation("Post_thread", fields: [rootId], references: [id], onDelete: Cascade)
  threadReplies Post[] @relation("Post_thread")

  boosts   Boost[]
  media    PostMedia[]
  bookmarks Bookmark[]
  mentions PostMention[]
  pinnedByUser User? @relation("PinnedPost")
  notificationsAsSubject Notification[] @relation("Notification_subjectPost")

  @@index([userId, createdAt])
  @@index([createdAt])
  @@index([parentId])
  @@index([parentId, createdAt])
  @@index([rootId])
  @@index([rootId, createdAt])
}

model PostMention {
  postId String
  userId String

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation("PostMention_user", fields: [userId], references: [id], onDelete: Cascade)

  @@id([postId, userId])
  @@index([userId])
}

model BookmarkCollection {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name String
  slug String

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  bookmarks BookmarkCollectionItem[]

  @@unique([userId, name])
  @@unique([userId, slug])
  @@index([userId, createdAt])
}

model Bookmark {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  postId String
  post   Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  collections BookmarkCollectionItem[]

  @@unique([userId, postId])
  @@index([userId, createdAt])
  @@index([postId, createdAt])
}

// Join table: one saved post can be in multiple folders.
model BookmarkCollectionItem {
  createdAt DateTime @default(now())

  bookmarkId   String
  collectionId String

  bookmark   Bookmark          @relation(fields: [bookmarkId], references: [id], onDelete: Cascade)
  collection BookmarkCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@id([bookmarkId, collectionId])
  @@index([collectionId, createdAt])
  @@index([bookmarkId, createdAt])
}

model PostMedia {
  id        String         @id @default(cuid())
  createdAt DateTime       @default(now())
  kind      PostMediaKind
  source    PostMediaSource
  // For "upload" sources, `r2Key` is set; `url` is computed server-side from R2 base URL.
  r2Key     String?
  // For video uploads, optional poster image stored in R2.
  thumbnailR2Key String?
  // For "giphy" sources, `url` is set (and optional mp4Url for better performance later).
  url       String?
  mp4Url    String?
  width     Int?
  height    Int?
  // For video: duration in seconds.
  durationSeconds Int?
  position  Int            @default(0)

  // Admin tombstone: media can be hard-deleted from storage, but we keep the row so posts can render a placeholder.
  deletedAt        DateTime?
  deletedByAdminId String?
  deletedReason    String?
  deletedByAdmin   User?    @relation("PostMedia_deletedByAdmin", fields: [deletedByAdminId], references: [id], onDelete: SetNull)

  postId String
  post   Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId, position])
  @@index([postId, createdAt])
  @@index([deletedAt])
}

// Dedupe: one row per unique file content (by SHA-256). Reuse existing R2 key when same file uploaded again.
model MediaContentHash {
  contentHash     String   @unique
  r2Key           String
  kind            PostMediaKind
  width           Int?
  height          Int?
  durationSeconds Int?
  bytes           Int?
  createdAt       DateTime @default(now())
}

// Admin indexed view of all R2-backed media objects (including orphans).
model MediaAsset {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())

  r2Key          String   @unique
  r2LastModified DateTime?
  bytes          Int?
  contentType    String?
  kind           PostMediaKind?
  width          Int?
  height         Int?

  deletedAt        DateTime?
  deletedByAdminId String?
  deleteReason     String?
  r2DeletedAt      DateTime?
  deletedByAdmin   User?    @relation("MediaAsset_deletedByAdmin", fields: [deletedByAdminId], references: [id], onDelete: SetNull)

  @@index([r2LastModified, id])
  @@index([deletedAt])
}

model Boost {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  postId String
  userId String

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId, createdAt])
  @@index([userId, createdAt])
}

// Singleton-ish table: holds site-wide configurable settings.
// Use `id=1` row as the canonical config.
model SiteConfig {
  id        Int      @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  postsPerWindow     Int @default(5)
  windowSeconds      Int @default(300)
}

model PhoneOtp {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  phone         String
  codeHash      String
  expiresAt     DateTime
  consumedAt    DateTime?
  resendAfterAt DateTime?

  @@index([phone, createdAt])
  @@index([expiresAt])
}

model Session {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  expiresAt DateTime
  revokedAt DateTime?
  tokenHash String    @unique

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model Notification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  deliveredAt DateTime?
  readAt    DateTime?

  recipientUserId String
  kind      NotificationKind
  actorUserId    String?
  subjectPostId  String?
  subjectUserId  String?
  title     String?
  body      String?

  recipient User  @relation("Notification_recipient", fields: [recipientUserId], references: [id], onDelete: Cascade)
  actor     User? @relation("Notification_actor", fields: [actorUserId], references: [id], onDelete: SetNull)
  subjectPost Post? @relation("Notification_subjectPost", fields: [subjectPostId], references: [id], onDelete: SetNull)
  subjectUser User? @relation("Notification_subjectUser", fields: [subjectUserId], references: [id], onDelete: SetNull)

  @@index([recipientUserId, createdAt])
  @@index([recipientUserId, deliveredAt])
  @@index([recipientUserId, readAt])
}

// Cached OpenGraph/link metadata for post previews (Microlink/Jina).
model LinkMetadata {
  id          String   @id @default(cuid())
  url         String   @unique
  title       String?
  description String?
  imageUrl    String?
  siteName    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([url])
}


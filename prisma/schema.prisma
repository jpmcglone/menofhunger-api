generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum VerifiedStatus {
  none
  identity
  manual
}

enum PostVisibility {
  public
  verifiedOnly
  premiumOnly
  onlyMe
}

enum FollowVisibility {
  all
  verified
  premium
  none
}

enum PostMediaKind {
  image
  gif
  video
}

enum PostMediaSource {
  upload
  giphy
}

enum NotificationKind {
  comment
  boost
  follow
  mention
  generic
}

enum FeedbackCategory {
  bug
  feature
  account
  other
}

enum FeedbackStatus {
  new
  triaged
  resolved
}

enum ReportTargetType {
  post
  user
}

enum ReportReason {
  spam
  harassment
  hate
  sexual
  violence
  illegal
  other
}

enum ReportStatus {
  pending
  dismissed
  actionTaken
}

enum VerificationRequestStatus {
  pending
  approved
  rejected
  cancelled
}

enum MessageConversationType {
  direct
  group
}

enum MessageParticipantStatus {
  pending
  accepted
}

enum MessageParticipantRole {
  owner
  member
}

// Start minimal. Add real domain models as you solidify your product.
model Example {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  name      String
}

model User {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  phone     String    @unique
  email     String?   @unique
  // Username stored as entered (case preserved). Uniqueness is enforced case-insensitively
  // via a functional unique index on LOWER(username) in a migration.
  username String?
  // Public profile fields.
  name String?
  bio  String?
  // Required onboarding fields (gates app access).
  // Stored as DateTime (UTC midnight) to keep Prisma portable.
  birthdate DateTime?
  interests String[] @default([])
  // Required onboarding acknowledgement (app store friendly wording; enforced in app).
  menOnlyConfirmed Boolean @default(false)
  // True when the user has explicitly chosen a username.
  usernameIsSet Boolean @default(false)
  // Minimal admin flag (will be replaced by real roles later).
  siteAdmin Boolean @default(false)
  // Premium flag (paid product access; used for visibility gating).
  premium Boolean @default(false)
  // Premium+ (superset of premium; special supporters tier).
  premiumPlus Boolean @default(false)
  // Verified badge (more roles/permissions later).
  verifiedStatus VerifiedStatus @default(none)
  verifiedAt DateTime?
  unverifiedAt DateTime?
  // Follow list privacy (controls counts + follower/following lists).
  followVisibility FollowVisibility @default(all)
  // Public media (stored in object storage; API stores keys only).
  avatarKey String?
  avatarUpdatedAt DateTime?
  bannerKey String?
  bannerUpdatedAt DateTime?
  // When the user last went offline (set by presence disconnect).
  lastOnlineAt DateTime?
  sessions  Session[]
  posts     Post[]
  boosts    Boost[]
  bookmarks Bookmark[]
  bookmarkCollections BookmarkCollection[]
  // Pinned post on profile (one per user; must be own post).
  pinnedPostId String? @unique
  pinnedPost   Post?   @relation("PinnedPost", fields: [pinnedPostId], references: [id], onDelete: SetNull)

  // Social graph (self-referential via Follow).
  // `following`: users this user follows (outgoing edges)
  // `followers`: users who follow this user (incoming edges)
  following Follow[] @relation("Follow_follower")
  followers Follow[] @relation("Follow_following")

  // Admin audit relations
  deletedPostMedia PostMedia[] @relation("PostMedia_deletedByAdmin")
  deletedMediaAssets MediaAsset[] @relation("MediaAsset_deletedByAdmin")
  mentionedIn PostMention[] @relation("PostMention_user")
  notificationsReceived Notification[] @relation("Notification_recipient")
  notificationsAsActor Notification[] @relation("Notification_actor")
  notificationsAsSubjectUser Notification[] @relation("Notification_subjectUser")
  pushSubscriptions PushSubscription[]
  userSearches     UserSearch[]
  feedbacks        Feedback[]
  reportsMade      Report[] @relation("Report_reporter")
  reportsReceived  Report[] @relation("Report_subjectUser")
  reportsResolved  Report[] @relation("Report_resolvedBy")
  verificationRequests VerificationRequest[] @relation("VerificationRequest_user")
  verificationRequestsReviewed VerificationRequest[] @relation("VerificationRequest_reviewedBy")
  messageParticipants MessageParticipant[] @relation("MessageParticipant_user")
  messagesSent        Message[] @relation("Message_sender")
  messageConversationsCreated MessageConversation[] @relation("MessageConversation_createdBy")
  blocksInitiated UserBlock[] @relation("UserBlock_blocker")
  blocksReceived  UserBlock[] @relation("UserBlock_blocked")
  popularScoreSnapshots PostPopularScoreSnapshot[] @relation("PostPopularScoreSnapshot_user")

  @@index([phone])
}

model UserSearch {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  query     String   @db.VarChar(200)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([createdAt])
  @@index([query])
}

model PushSubscription {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  userId   String
  endpoint String   @db.Text
  p256dh   String   @db.Text
  auth     String   @db.Text
  userAgent String? @db.Text

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, endpoint])
  @@index([userId])
}

model Follow {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  followerId  String
  followingId String

  follower  User @relation("Follow_follower", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("Follow_following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId, createdAt])
  @@index([followingId, createdAt])
  // Speeds up mutual/friends-of-friends queries that walk edges in reverse.
  @@index([followingId, followerId])
}

model Post {
  id         String         @id @default(cuid())
  createdAt  DateTime       @default(now())
  deletedAt  DateTime?
  body       String
  /** Inferred topics (from allowlist) used for search/discovery. */
  topics     String[]       @default([])
  /** User-created hashtags (parsed from body) used for search/autocomplete. Stored lowercase. */
  hashtags   String[]       @default([])
  /** Hashtag casing variants used in this post (one per entry in `hashtags`, without '#'). */
  hashtagCasings String[]   @default([])
  visibility PostVisibility @default(public)
  boostCount Int            @default(0)
  bookmarkCount Int         @default(0)
  commentCount Int          @default(0)
  boostScore Float?
  boostScoreUpdatedAt DateTime?

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  parentId String?
  parent   Post?   @relation("Post_replies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Post[] @relation("Post_replies")

  // Root post ID for thread hierarchy (null for root posts, set to root post ID for all replies in a thread)
  rootId String?
  root   Post?   @relation("Post_thread", fields: [rootId], references: [id], onDelete: Cascade)
  threadReplies Post[] @relation("Post_thread")

  boosts   Boost[]
  media    PostMedia[]
  bookmarks Bookmark[]
  mentions PostMention[]
  pinnedByUser User? @relation("PinnedPost")
  notificationsAsSubject Notification[] @relation("Notification_subjectPost")
  popularScoreSnapshots PostPopularScoreSnapshot[] @relation("PostPopularScoreSnapshot_post")
  reports Report[] @relation("Report_subjectPost")

  @@index([userId, createdAt])
  @@index([createdAt])
  @@index([parentId])
  @@index([parentId, createdAt])
  @@index([rootId])
  @@index([rootId, createdAt])
  @@index([topics], type: Gin)
  @@index([hashtags], type: Gin)
  // Feed/trending hot paths (parentId IS NULL + deletedAt IS NULL) benefit from composite indexes matching sort+filters.
  @@index([parentId, deletedAt, createdAt(sort: Desc), id(sort: Desc)])
  @@index([parentId, deletedAt, boostCount(sort: Desc), createdAt(sort: Desc), id(sort: Desc)])
  @@index([parentId, deletedAt, bookmarkCount(sort: Desc), createdAt(sort: Desc), id(sort: Desc)])
  @@index([parentId, deletedAt, commentCount(sort: Desc), createdAt(sort: Desc), id(sort: Desc)])
}

model Hashtag {
  tag String @id

  usageCount Int @default(0)
  /** Most common casing for display/autocomplete, e.g. "HashTags". */
  displayTag String?
  /** Count for `displayTag` (ties keep existing). */
  displayTagCount Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  variants HashtagVariant[]

  @@index([usageCount])
  @@index([updatedAt])
}

model HashtagVariant {
  tag     String
  variant String
  count   Int @default(0)

  hashtag Hashtag @relation(fields: [tag], references: [tag], onDelete: Cascade)

  @@id([tag, variant])
  @@index([tag])
  @@index([count])
}

model HashtagBackfillRun {
  id String @id @default(cuid())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  status String @default("running")
  /** Post id cursor for createdAt/id pagination. */
  cursor String?
  processedPosts Int @default(0)
  updatedPosts Int @default(0)
  resetDone Boolean @default(false)
  startedAt DateTime @default(now())
  finishedAt DateTime?
  lastError String? @db.Text

  @@index([status, updatedAt])
}

// Postgres-backed "cache": periodic snapshots of trending scores.
// We keep a small rolling window (e.g. last ~1 hour) so cursor pagination remains stable across refreshes.
model PostPopularScoreSnapshot {
  asOf      DateTime
  postId    String
  createdAt DateTime
  score     Float

  userId     String
  visibility PostVisibility

  parentId String?
  rootId   String?

  post Post @relation("PostPopularScoreSnapshot_post", fields: [postId], references: [id], onDelete: Cascade)
  user User @relation("PostPopularScoreSnapshot_user", fields: [userId], references: [id], onDelete: Cascade)

  @@id([asOf, postId])
  @@index([asOf, score(sort: Desc), createdAt(sort: Desc), postId(sort: Desc)])
  @@index([asOf, userId])
  @@index([asOf, visibility])
}

// Postgres-backed "cache": periodic snapshots of trending hashtag scores.
// We keep a small rolling window (e.g. last ~1 hour) so paging remains stable across refreshes.
model HashtagTrendingScoreSnapshot {
  asOf DateTime
  /** Canonical lowercase tag (no '#'). */
  tag String
  visibility PostVisibility
  /** Time-decayed score (half-life based); used for ranking only. */
  score Float
  /** Raw usage count within the lookback window (not time-decayed). */
  usageCount Int

  @@id([asOf, visibility, tag])
  @@index([asOf, visibility, score(sort: Desc), usageCount(sort: Desc), tag(sort: Asc)])
  @@index([asOf, tag])
}

model PostMention {
  postId String
  userId String

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation("PostMention_user", fields: [userId], references: [id], onDelete: Cascade)

  @@id([postId, userId])
  @@index([userId])
}

model BookmarkCollection {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name String
  slug String

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  bookmarks BookmarkCollectionItem[]

  @@unique([userId, name])
  @@unique([userId, slug])
  @@index([userId, createdAt])
}

model Bookmark {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  postId String
  post   Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  collections BookmarkCollectionItem[]

  @@unique([userId, postId])
  @@index([userId, createdAt])
  @@index([postId, createdAt])
}

// Join table: one saved post can be in multiple folders.
model BookmarkCollectionItem {
  createdAt DateTime @default(now())

  bookmarkId   String
  collectionId String

  bookmark   Bookmark          @relation(fields: [bookmarkId], references: [id], onDelete: Cascade)
  collection BookmarkCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@id([bookmarkId, collectionId])
  @@index([collectionId, createdAt])
  @@index([bookmarkId, createdAt])
}

model PostMedia {
  id        String         @id @default(cuid())
  createdAt DateTime       @default(now())
  kind      PostMediaKind
  source    PostMediaSource
  // For "upload" sources, `r2Key` is set; `url` is computed server-side from R2 base URL.
  r2Key     String?
  // For video uploads, optional poster image stored in R2.
  thumbnailR2Key String?
  // For "giphy" sources, `url` is set (and optional mp4Url for better performance later).
  url       String?
  mp4Url    String?
  width     Int?
  height    Int?
  // For video: duration in seconds.
  durationSeconds Int?
  // Optional alt text for accessibility.
  alt       String?
  position  Int            @default(0)

  // Admin tombstone: media can be hard-deleted from storage, but we keep the row so posts can render a placeholder.
  deletedAt        DateTime?
  deletedByAdminId String?
  deletedReason    String?
  deletedByAdmin   User?    @relation("PostMedia_deletedByAdmin", fields: [deletedByAdminId], references: [id], onDelete: SetNull)

  postId String
  post   Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId, position])
  @@index([postId, createdAt])
  @@index([deletedAt])
}

// Dedupe: one row per unique file content (by SHA-256). Reuse existing R2 key when same file uploaded again.
model MediaContentHash {
  contentHash     String   @unique
  r2Key           String
  kind            PostMediaKind
  width           Int?
  height          Int?
  durationSeconds Int?
  bytes           Int?
  createdAt       DateTime @default(now())
}

// Admin indexed view of all R2-backed media objects (including orphans).
model MediaAsset {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())

  r2Key          String   @unique
  r2LastModified DateTime?
  bytes          Int?
  contentType    String?
  kind           PostMediaKind?
  width          Int?
  height         Int?

  deletedAt        DateTime?
  deletedByAdminId String?
  deleteReason     String?
  r2DeletedAt      DateTime?
  deletedByAdmin   User?    @relation("MediaAsset_deletedByAdmin", fields: [deletedByAdminId], references: [id], onDelete: SetNull)

  @@index([r2LastModified, id])
  @@index([deletedAt])
}

model Boost {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  postId String
  userId String

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId, createdAt])
  @@index([userId, createdAt])
}

// Singleton-ish table: holds site-wide configurable settings.
// Use `id=1` row as the canonical config.
model SiteConfig {
  id        Int      @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  postsPerWindow     Int @default(5)
  windowSeconds      Int @default(300)
}

model PhoneOtp {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  phone         String
  codeHash      String
  expiresAt     DateTime
  consumedAt    DateTime?
  resendAfterAt DateTime?

  @@index([phone, createdAt])
  @@index([expiresAt])
}

model Session {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  expiresAt DateTime
  revokedAt DateTime?
  tokenHash String    @unique

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model Notification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  deliveredAt DateTime?
  readAt    DateTime?

  recipientUserId String
  kind      NotificationKind
  actorUserId    String?
  subjectPostId  String?
  subjectUserId  String?
  title     String?
  body      String?

  recipient User  @relation("Notification_recipient", fields: [recipientUserId], references: [id], onDelete: Cascade)
  actor     User? @relation("Notification_actor", fields: [actorUserId], references: [id], onDelete: SetNull)
  subjectPost Post? @relation("Notification_subjectPost", fields: [subjectPostId], references: [id], onDelete: SetNull)
  subjectUser User? @relation("Notification_subjectUser", fields: [subjectUserId], references: [id], onDelete: SetNull)

  @@index([recipientUserId, createdAt])
  @@index([recipientUserId, deliveredAt])
  @@index([recipientUserId, readAt])
  // Common list ordering/pagination: ORDER BY createdAt DESC, id DESC.
  @@index([recipientUserId, createdAt(sort: Desc), id(sort: Desc)])
}

model MessageConversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  type MessageConversationType
  title String?
  createdByUserId String
  /** Unique key for direct conversations (sorted user ids). */
  directKey String? @unique

  lastMessageAt DateTime?
  lastMessageId String? @unique

  createdBy User @relation("MessageConversation_createdBy", fields: [createdByUserId], references: [id], onDelete: Cascade)
  participants MessageParticipant[]
  messages Message[] @relation("MessageConversation_messages")
  lastMessage Message? @relation("MessageConversation_lastMessage", fields: [lastMessageId], references: [id], onDelete: SetNull)

  @@index([type, updatedAt])
  @@index([lastMessageAt, id])
}

model MessageParticipant {
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  conversationId String
  userId String
  role MessageParticipantRole @default(member)
  status MessageParticipantStatus @default(pending)
  acceptedAt DateTime?
  lastReadAt DateTime?

  conversation MessageConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user User @relation("MessageParticipant_user", fields: [userId], references: [id], onDelete: Cascade)

  @@id([conversationId, userId])
  @@index([userId, status, updatedAt])
  @@index([conversationId, updatedAt])
}

model Message {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  body      String   @db.Text

  conversationId String
  senderId String

  conversation MessageConversation @relation("MessageConversation_messages", fields: [conversationId], references: [id], onDelete: Cascade)
  sender User @relation("Message_sender", fields: [senderId], references: [id], onDelete: Cascade)
  lastMessageFor MessageConversation? @relation("MessageConversation_lastMessage")

  @@index([conversationId, createdAt])
  @@index([senderId, createdAt])
}

model UserBlock {
  createdAt DateTime @default(now())

  blockerId String
  blockedId String

  blocker User @relation("UserBlock_blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("UserBlock_blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@id([blockerId, blockedId])
  @@index([blockerId, createdAt])
  @@index([blockedId, createdAt])
}

model Feedback {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  category FeedbackCategory
  status   FeedbackStatus @default(new)
  email    String?        @db.VarChar(200)
  subject  String         @db.VarChar(200)
  details  String         @db.Text
  adminNote String?       @db.Text

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([createdAt, id])
  @@index([status, createdAt])
  @@index([category, createdAt])
}

model Report {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  targetType ReportTargetType
  reason     ReportReason
  details    String?      @db.Text

  status     ReportStatus @default(pending)
  adminNote  String?      @db.Text
  resolvedAt DateTime?

  reporterUserId String
  reporter       User   @relation("Report_reporter", fields: [reporterUserId], references: [id], onDelete: Cascade)

  subjectUserId String?
  subjectUser   User?  @relation("Report_subjectUser", fields: [subjectUserId], references: [id], onDelete: Cascade)

  subjectPostId String?
  subjectPost   Post?  @relation("Report_subjectPost", fields: [subjectPostId], references: [id], onDelete: Cascade)

  resolvedByAdminId String?
  resolvedByAdmin   User? @relation("Report_resolvedBy", fields: [resolvedByAdminId], references: [id], onDelete: SetNull)

  @@index([createdAt, id])
  @@index([status, createdAt])
  @@index([targetType, createdAt])
  @@index([reporterUserId, createdAt])
  @@index([subjectUserId, createdAt])
  @@index([subjectPostId, createdAt])
}

model VerificationRequest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation("VerificationRequest_user", fields: [userId], references: [id], onDelete: Cascade)

  status VerificationRequestStatus @default(pending)

  // Provider-agnostic fields (null until a provider is integrated).
  provider String? @db.VarChar(50)
  providerRequestId String? @db.VarChar(200)
  metadata Json?

  // Admin review fields.
  reviewedAt DateTime?
  reviewedByAdminId String?
  reviewedByAdmin User? @relation("VerificationRequest_reviewedBy", fields: [reviewedByAdminId], references: [id], onDelete: SetNull)
  adminNote String? @db.Text
  rejectionReason String? @db.Text

  @@index([createdAt, id])
  @@index([userId, createdAt])
  @@index([status, createdAt])
  @@index([provider, providerRequestId])
}

// Cached OpenGraph/link metadata for post previews (Microlink/Jina).
model LinkMetadata {
  id          String   @id @default(cuid())
  url         String   @unique
  title       String?
  description String?
  imageUrl    String?
  siteName    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([url])
}

